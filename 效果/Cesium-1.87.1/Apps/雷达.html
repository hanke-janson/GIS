<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Use correct character set. -->
    <meta charset="utf-8" />
    <!-- Tell IE to use the latest, best version. -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
    <title>Hello World!</title>
    <script src="../Build/Cesium/Cesium.js"></script>
    <style>
        @import url(../Build/Cesium/Widgets/widgets.css);

        html,
        body,
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="cesiumContainer"></div>
    <script>
        viewer = new Cesium.Viewer("cesiumContainer", {
            animation: false, // 隐藏动画控件
            baseLayerPicker: false, // 隐藏图层选择控件
            fullscreenButton: false, // 隐藏全屏按钮
            vrButton: false, // 隐藏VR按钮，默认false
            geocoder: false, // 隐藏地名查找控件
            homeButton: false, // 隐藏Home按钮
            infoBox: false, // 隐藏点击要素之后显示的信息窗口
            sceneModePicker: false, // 隐藏场景模式选择控件
            selectionIndicator: true, // 显示实体对象选择框，默认true
            timeline: false, // 隐藏时间线控件
            navigationHelpButton: false, // 隐藏帮助按钮
            scene3DOnly: true, // 每个几何实例将只在3D中呈现，以节省GPU内存
            shouldAnimate: true, // 开启动画自动播放
            sceneMode: 3, // 初始场景模式 1：2D 2：2D循环 3：3D，默认3
            requestRenderMode: true, // 减少Cesium渲染新帧总时间并减少Cesium在应用程序中总体CPU使用率
            // 如场景中的元素没有随仿真时间变化，请考虑将设置maximumRenderTimeChange为较高的值，例如Infinity
            // maximumRenderTimeChange: Infinity,
            imageryProvider: new Cesium.UrlTemplateImageryProvider({
                url: "http://localhost:8889/bm/map/{z}/{x}/{y}",
                maximumLevel: 14,
            })
        })
        // 去除logo
        viewer.cesiumWidget.creditContainer.style.display = "none";

        /*
     * @Description: 立体雷达扫描效果（参考开源代码）
     * @Version: 1.0
     * @Author: Julian
     * @Date: 2022-03-05 10:22:01
     * @LastEditors: Julian
     * @LastEditTime: 2022-03-05 15:04:44
     */
        function radarSolidScan(options) {
            this._viewer = options.viewer;
            // 半径
            this._radius = options.radius;
            // 扫描扇形颜色
            this._color = options.color;
            // 扫描速度
            this._speed = options.speed;
            // 中心点坐标经纬度
            this._cenLon = options.position[0];
            this._cenLat = options.position[1];

            // 先建立椭球体
            this._viewer.entities.add({
                position: new Cesium.Cartesian3.fromDegrees(this._cenLon, this._cenLat),
                name: "立体雷达扫描",
                ellipsoid: {
                    radii: new Cesium.Cartesian3(this._radius, this._radius, this._radius),
                    material: this._color,
                    outline: true,
                    outlineColor: new Cesium.Color(1.0, 1.0, 0.0, 1.0),
                    outlineWidth: 1,
                }
            })

            let heading = 0;
            // 每一帧刷新时调用
            this._viewer.clock.onTick.addEventListener(() => {
                heading += this._speed;
                positionArr = calculatePane(113.9236839, 22.528061, 1000.0, heading);
            })

            // 创建1/4圆形立体墙
            let radarWall = this._viewer.entities.add({
                wall: {
                    positions: new Cesium.CallbackProperty(() => {
                        return Cesium.Cartesian3.fromDegreesArrayHeights(positionArr);
                    }, false),
                    material: this._color,
                }
            })

            // 计算平面扫描范围
            function calculatePane(x1, y1, radius, heading) {
                var m = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(x1, y1));
                var rx = radius * Math.cos(heading * Math.PI / 180.0);
                var ry = radius * Math.sin(heading * Math.PI / 180.0);
                var translation = Cesium.Cartesian3.fromElements(rx, ry, 0);
                var d = Cesium.Matrix4.multiplyByPoint(m, translation, new Cesium.Cartesian3());
                var c = Cesium.Cartographic.fromCartesian(d);
                var x2 = Cesium.Math.toDegrees(c.longitude);
                var y2 = Cesium.Math.toDegrees(c.latitude);
                return calculateSector(x1, y1, x2, y2);
            }

            // 计算竖直扇形
            function calculateSector(x1, y1, x2, y2) {
                let positionArr = [];
                positionArr.push(x1);
                positionArr.push(y1);
                positionArr.push(0);
                var radius = Cesium.Cartesian3.distance(Cesium.Cartesian3.fromDegrees(x1, y1), Cesium.Cartesian3.fromDegrees(x2, y2));
                // 扇形是1/4圆，因此角度设置为0-90
                for (let i = 0; i <= 90; i++) {
                    let h = radius * Math.sin(i * Math.PI / 180.0);
                    let r = Math.cos(i * Math.PI / 180.0);
                    let x = (x2 - x1) * r + x1;
                    let y = (y2 - y1) * r + y1;
                    positionArr.push(x);
                    positionArr.push(y);
                    positionArr.push(h);
                }
                return positionArr;
            }
        }

        radarSolidScan({
            viewer: this.viewer,
            position: [113.9236839, 22.528061],
            radius: 1000.0,
            color: new Cesium.Color(1.0, 1.0, 0.0, 0.3),
            speed: 5.0
        })
        viewer.camera.flyTo({
                destination: Cesium.Cartesian3.fromDegrees(113.9236839, 22.528061),
                orientation: {
                    heading: 0.7428807310723249,
                    pitch: -0.11817318020507717
                }
            });
 

    </script>

</body>

</html>